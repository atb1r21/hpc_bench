DL_MG to do list

25/7/21 - 

regarding work on new2ord branch and continuation:

1) check if the argument remove_source_zero_mode is needed
   it seems a better alternative to neutralize the source term
   before calling the solver
   decision to be taken after newton is adapted

5) add a new module with vector types.
     rename y_ => b_ (with boundary)
            z_ => i_ (interior only)

7) analyze if an inc file with error codes makes sense

10)  try to remove omp barriers in kernels call if safe

11)  Add a Jacobi smoother for level 1

12)  optimise data transfers in multigrid driver 
     with boundary copy

13)  review remove potential zeor mode,
     it nees streamlining

Z)  this is a miniproject for a later date
     -Test the algorithm that uses Newton with higer order derivaties
      and defco for the associante linear problem
      - investigate if GEMRES or BICGSTAB are better that the iterative
        procedure used now to solve defco

3)X analyse the best whay to implement the recursion
    cg -> mg -> cg (level 1; if nlevel > 1)
    - or perhaps specilized subroutine
    - put on hold, MG Vcycles should be right preconditioner
      and CG on top
    - perhapa it's worth a second look later

2)V investigate if remove solution zero mode ( full PBC) is needed
   in CG without preconditioner.

4)V move back mass term in MG setup
     I think that is needed only there and it's dangerous
     to have it moving around.

6)V Add a test for pbe + pbc

8)V adapt residual kernel to compute A v with a swicth to set f = 0
    - kernel calls reorganized in newton (30/7/21)

9)V   Check if the vector sol can be optimised out in newton solver

11)V  move the mas term at the start of newton loop, to save some expontial
     computations. Adapt the cases in blocked_diagmatv.

12)  add a Jacobi smother on level 1 in order to gain one more MG level



Updated: 06/02/17

CRITICAL

[X] Remove redundant ONETEP code from dl_mg_defco module
[ ] Bring documentation of dl_mg_defco_* modules up to date
[X] Check that tolerances for solver and defect correction used in defect 
    correction loop are consistent with those in ONETEP (tol, tol_mg)

DESIRABLE

[ ] Add test to prevent use of aggregation, as this is not a supported feature
    in the current version of DL_MG.
[ ] Check value of hartree in dl_mg_params module -- I am relatively sure that 
    this is incorrect (it disagrees with the value of k_B from ONETEP in the 
    6th significant figure)
[ ] Script for checking Fortran module dependencies in Makefile
[ ] Extend the interfaces for dl_mg_solver_* to provide a parameter that 
    signals unsued arguments (DL_MG_IGNORE), e.g. for eps_full if fd_order == 2.
[X] Make steric_pot an argument for dl_mg_defco_defect_corr_solver, rather than
    accessing directly from dl_mg_common_data module, use present() rather than
    associated().
    - Removed any need for pointers / allocatable array, since we can simply
      use the optional argument throughout.
[ ] further changes to dl_mg_defco_fd_mod.f90
    - parallel_prepare_fd_halo to become a contained subroutine in
      dl_mg_fd_derivative
    - halo_left, halo_right to be local in dl_mg_fd_derivative
[ ] explore if some performance gain can be achieved if one allocates
    only 1 buffer for MPI communication and buffsend(:)%b are pointer to
    section of that buffer
[ ] extend OpenMP regions in dl_mg_defco_mod and dl_mg_defco_fd_mod
[ ] explore the performance gain if the defco halo exchange involves OpenMP
    threads.
    Options:
    - master thread created tasks for other threads to copy data from
      mpi buffers in halo buffers
    - compute the contribution from local domain with while master threads
      prepares the halo buffer
[ ] add tags in log file to the lines generated by multigrid and Newton
    cycles similar to DEFCO. This will help to grep quickly for the info
    of interest.
[ ] add a mechanism to control the amount of logged data tunable with an
    environment variable.
[ ] in mg_test uses input and out arrays larger that the local grids to
    test if arbitrary index block can be passed to DL_MG.
    This would be useful as applications could use halo regions in their
    data structures.
[ ] clarify the convergence criteria for defect correction. Current version
    used ||error|| < tol. DL_MG and Newton use residual reduction.
    I think that the same should be used in defco, i.e. iteration should
    stop if the defect norm is bellow a given tolerance.
[ ] converge tolerances are used in V cycle, coarse level, Newton and defco.
    For a better control one should collect the tolerance info in one
    data structure, a module or a derived type.
